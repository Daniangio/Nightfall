from typing import Optional, TYPE_CHECKING
import pygame

from nightfall.client.ui.components.base_component import BaseComponent
from nightfall.client.ui.components.queue_components import BuildQueueComponent, UnitQueueComponent

if TYPE_CHECKING:
    # This block is only read by type checkers, not at runtime
    from nightfall.client.ui_manager import UIManager
    from nightfall.core.state.game_state import GameState

# Colors - It's good practice for components to define or import their own colors
C_GRAY = (50, 50, 50)
C_RED = (200, 0, 0)
C_GREEN = (0, 200, 0)
C_WHITE = (255, 255, 255)
C_YELLOW = (255, 215, 0)
C_LIGHT_GRAY = (150, 150, 150)

class ResourcePanelComponent(BaseComponent):
    def handle_event(self, event: pygame.event.Event, *args, **kwargs) -> Optional[dict]:
        return None # This panel is display-only

    def draw(self, screen: pygame.Surface, ui_manager: "UIManager", game_state: "GameState", city, production):
        resource_rect = ui_manager.resource_panel_rect
        pygame.draw.rect(screen, (30,30,30), resource_rect, border_radius=8)
        
        res_y = resource_rect.y + 15
        res = city.resources
        
        font_s = ui_manager.font_s
        
        # Helper to draw text
        def draw_text(text, pos, font=font_s, color=C_WHITE):
            surface = font.render(text, True, color)
            screen.blit(surface, pos)

        draw_text(f"Food: {int(res.food)} (+{production.food if production else 0})", (resource_rect.x + 20, res_y))
        res_y += 25
        draw_text(f"Wood: {int(res.wood)} (+{production.wood if production else 0})", (resource_rect.x + 20, res_y))
        res_y += 25
        draw_text(f"Iron: {int(res.iron)} (+{production.iron if production else 0})", (resource_rect.x + 20, res_y))
        res_y += 25
        draw_text(f"Buildings: {city.num_buildings} / {city.max_buildings}", (resource_rect.x + 20, res_y))


class SidePanelComponent(BaseComponent):
    def __init__(self, ui_manager: "UIManager"):
        self.ui_manager = ui_manager
        self.font_m = ui_manager.font_m
        self.font_s = ui_manager.font_s
        
        # The panel owns its sub-components
        self.resource_panel = ResourcePanelComponent()
        self.build_queue_panel = BuildQueueComponent(ui_manager)
        self.unit_queue_panel = UnitQueueComponent(ui_manager)

    def handle_event(self, event: pygame.event.Event, game_state: "GameState", **kwargs) -> Optional[dict]:
        # The action_queue passed here is the client's local prediction queue, which is not what the UI displays.
        # The UI displays the city's build_queue. We get that from the game_state.
        city = game_state.cities.get(self.ui_manager.viewed_city_id)
        build_queue = city.build_queue if city else []
        # Delegate events to sub-components first
        action = self.build_queue_panel.handle_event(event, game_state, build_queue)
        if action: return action

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            # --- Handle Splitter Drag ---
            if self.ui_manager.splitter_rect.collidepoint(event.pos):
                self.ui_manager.is_dragging_splitter = True
                return None
            if self.ui_manager.queue_splitter_rect.collidepoint(event.pos):
                self.ui_manager.is_dragging_queue_splitter = True
                return None

            # --- Handle Button Clicks ---
            if self.ui_manager.buttons['exit_session'].collidepoint(event.pos):
                return {"type": "exit_session"}

        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.ui_manager.is_dragging_splitter = False
            self.ui_manager.is_dragging_queue_splitter = False

        elif event.type == pygame.MOUSEMOTION:
            if self.ui_manager.is_dragging_splitter:
                new_panel_width = self.ui_manager.screen_width - event.pos[0] # The action_queue is needed for layout recalculation
                self.ui_manager.update_side_panel_width(new_panel_width, build_queue)
            elif self.ui_manager.is_dragging_queue_splitter:
                self._handle_queue_splitter_drag(event, build_queue)

        return None # No action generated by the panel itself

    def _handle_queue_splitter_drag(self, event: pygame.event.Event, action_queue: list):
        from nightfall.client.ui_manager import DEFAULT_SCREEN_WIDTH, DEFAULT_SCREEN_HEIGHT
        total_y_start = self.ui_manager.resource_panel_rect.bottom + 10
        total_y_end = DEFAULT_SCREEN_HEIGHT - 10
        total_height = total_y_end - total_y_start
        if total_height <= 0: return

        splitter_pos_relative = event.pos[1] - total_y_start
        max_content_height = 40 + (len(action_queue) * 30)
        clamped_splitter_pos = min(splitter_pos_relative, max_content_height)

        new_ratio = clamped_splitter_pos / total_height
        self.ui_manager.queue_split_ratio = max(0.05, min(0.95, new_ratio))
        self.ui_manager.update_queue_layouts(action_queue)

    def draw(self, screen: pygame.Surface, game_state: "GameState", city, production, action_queue, simulator):
        side_panel_rect = self.ui_manager.side_panel_rect
        screen.fill(C_GRAY, side_panel_rect)

        # Draw splitter
        splitter_color = C_YELLOW if self.ui_manager.is_dragging_splitter else C_LIGHT_GRAY
        pygame.draw.rect(screen, splitter_color, self.ui_manager.splitter_rect)

        if not city:
            screen.blit(self.font_m.render("No city selected.", True, C_WHITE), (side_panel_rect.x + 20, side_panel_rect.y + 20))
            return

        # Draw sub-components
        self.resource_panel.draw(screen, self.ui_manager, game_state, city, production)
        self.build_queue_panel.draw(screen, self.ui_manager, game_state, simulator, action_queue)
        self.unit_queue_panel.draw(screen, self.ui_manager, city)

        # Draw queue splitter
        splitter_color = C_YELLOW if self.ui_manager.is_dragging_queue_splitter else C_LIGHT_GRAY
        pygame.draw.rect(screen, splitter_color, self.ui_manager.queue_splitter_rect)

        # Draw elements owned by the panel itself (like headers and global buttons)
        screen.blit(self.font_m.render(f"City: {city.name}", True, C_WHITE), (side_panel_rect.x + 20, 20))

        exit_rect = self.ui_manager.buttons['exit_session']
        pygame.draw.rect(screen, C_RED, exit_rect, border_radius=5)
        text_surf = self.font_s.render("Exit to Lobby", True, C_WHITE)
        screen.blit(text_surf, text_surf.get_rect(center=exit_rect.center))
